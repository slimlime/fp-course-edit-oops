Parser
    * Follow the Types to answer.
    * The types are less polymorphic, and so less reliable, but will still generally get you there.
    * Parser has one constructor, called P. There is *only one* way to make a Parser,
        by this constructor.
        * Or a function that calls the constructor for you.
    * ParseResult is a Functor.
        * (<$>) :: (a -> b) -> ParseResult a -> ParseResult b
    * For any X, if you have completed instance Monad X, you have also completed:
        * instance Applicative X
        * instance Functor X
        * by authoring a mechanical implementation (there is no thinking here, only data entry)


* 
anything that maps
Functor anything (f) that maps :: (a -> b) -> f a -> f b
satifies laws of id and composition
arrowT is a functor.. optional... 


Applicative
* satisfies 4 laws
identity
pure id <*>apply on x always get x
2 composition
3 homomorphism
4 interchange

need to follow laws otherwise get bugs

George going to international talk.

